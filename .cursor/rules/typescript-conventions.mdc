---
description: "TypeScript and import conventions"
globs: "*.ts,*.tsx"
alwaysApply: false
---

# TypeScript Conventions

## Strict Typing

- Never use `any` â€” use `unknown` for unknown values
- Explicit return types for public APIs and exported functions
- Use `interface` for component props, not `type`
- Union types over enums when appropriate

```typescript
// Good
interface UserCardProps {
  name: string;
  role: "admin" | "editor" | "viewer";
}

const UserCard = ({ name, role }: UserCardProps): React.ReactElement => (
  <Chip label={`${name} (${role})`} />
);

// Bad
const UserCard = ({ name, role }: any) => (
  <Chip label={`${name} (${role})`} />
);
```

## Imports

Group imports with blank lines between groups:

```typescript
// 1. Framework
import { useState } from "react";

// 2. Third-party
import Box from "@mui/material/Box";

// 3. Local
import { useAppStore } from "@/store";
import type { IAppStore } from "@/store";
import { CardRoot } from "./styled";
```

- Use `import type` for type-only imports
- Prefer named imports over default imports
- No duplicate import sources

## Functions

- Always use function expressions: `const fn = () => {}`
- Never use function declarations: `function fn() {}`
- Exception: `export default function` for Next.js pages/layouts

## Object Arguments

Functions with 2+ parameters must use a single object:

```typescript
// Good
const createUser = ({ name, email, role }: CreateUserParams) => { /* ... */ };

// Bad
const createUser = (name: string, email: string, role: string) => { /* ... */ };
```
